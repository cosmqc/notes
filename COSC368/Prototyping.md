- Goal is to improve UX through good UI design
- To make the most of limited time, quality of prototypes should be inversely proportional to the quantity of options.
#### Low-fidelity - sketches
- **Sketching is about ideas not art**, doesn't need to look good
- Should show structure of design and outward appearance
- Focus on high-level concepts
- Delays commitment - not over-committed to one idea
- Annotations to show how user moves through UI
- Vertical prototype -> One/few features, high level of functionality
- Horizontal prototype -> Many features, but only not much functionality / only blue skies
#### Medium/high-fidelity - wireframes / animations
- Shows what interaction with the user will look like
- Allows us to simulate functionality (animations, motion paths, etc)
- Beware of giving 'nearly completed' -> makes design reluctant to change
- Excessive focus on presentation rather than approach/functionality
#### Iterative Design Process
- Cyclic process of prototyping, testing, analysing, and refining a product/process
- Based on testing, refinements are made
- Improves quality and function of design
- Beware of tunnel vision - premature commitment, local maximum
- **Ideation** - Generating many ideas/variations, choose set of most promising, iterate
#### System-centered design
- Bad, don't do
- Focuses on the system's and designer's needs (the only parties not using the app)
  - What can we easily build?
  - What do I (the programmer) find interesting?
- Poor user experience -> important to balance system efficiency and user experience
- Decreased accessibility and inclusivity
#### Task-centered design
- Designs interfaces based on users' real world tasks
- HCI Equivalent of use cases / requirements analysis
- Define exactly who the users and what they want to do ('Mary' not 'User')
- Four phases:
  - User Identification
    - Identify specific users and articulate their concrete tasks
    - Categories of users: typical/extreme cases, novice/expert, casual/frequent
  - Requirements / Task identification
    - Decide which tasks and users the design will support
    - Record **what** the user wants to do (minimize the **how**/interface assumptions)
    - Record the complete task (input source, output destination)
    - Number/label tasks so they can be referred to later (SP15)
  - Design
    - Base design on tasks and how well design fits specific users
    - Use task categories/scenarios to generate/evaluate designs
    - **HOW** will a user complete the task?
  - Walkthrough evaluation
    - Using design, walk through the tasks to test the interface

- Tasks often conform to process, so hard to identify tasks that are independent of workflow -> hinders identification of better ways to achieve tasks 
#### User-centered design
- Focus on users and their needs in each phase of the design process
#### Partitipatory / Co-design
Getting users to help you design the product.
Interviews / co-design workshops:
- Helps discover user's culture, requirements, expectation
- Interview while doing their job - contextual inquiry
Explain designs:
- Get input at all design stages
- Important to have demos

**Participation** allows for more input at the design stages, including defining the agenda or the design activities

**Co-design** is where participants are treated as equals and have an equal say as the designers/researchers

Pros:
- Users are good at reacting to suggested designs (must be concrete and visible)
- They bring important 'folk' knowledge of context (stuff the design team wont know about)
Cons:
- Hard to get a good pool of end users - users sometimes reluctant to help
- Users are not expert designers - don't expect them to come up with their own ideas
- The user is not always right - don't expect them to know what they want

#### Wizard of Oz study (mechanical turk?)
- User interacts with a mock interface controlled by a person
- Helps test designs powered by complex technology
- Designers act as the complex technology
- Examples include AI chatbots (instead just a chatroom w other dev), learning algorithms, real-time info algorithms
- Benefit: low cost, low commitment (don't need to build tech before making sure users want it)

- Closed/Hybrid/Open response methods
  - Fixed options means less time to craft a custom one, easier to analyze
  - Open options means the test can continue if the user says/does something unexpected
  - Hybrid is a mix (list of options + custom if necessary), most flexible